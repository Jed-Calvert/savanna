---
title: "Untitled"
output: html_document
date: "2024-10-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
test1 <- read.csv("100k_random_points_comparison.csv")
```

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)

# Assuming you have your dataframe named test1
# test1 <- data.frame(ALS = ..., CNN = ...)

# (a) Scatterplot of ALS vs CNN
ggplot(test1, aes(x = ALS, y = CNN)) +
  geom_point(alpha = 0.05) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +  # Add a reference line
  labs(title = "",
       x = "Observed ALS",
       y = "Predicted CNN") +
  theme_minimal()

# (b) Calculate residuals
test1 <- test1 %>%
  mutate(residuals = ALS - CNN)
```

```{r}
# Load required library
library(dplyr)

test1 <- na.omit(test1)

# Calculate the metrics
n <- nrow(test1)  # Total number of observations
observed <- test1$ALS
predicted <- test1$CNN

# Calculate Mean Absolute Error (MAE)
mae <- sum(abs(observed - predicted)) / n

# Calculate Root Mean Squared Error (RMSE)
rmse <- sqrt(sum((observed - predicted)^2) / n)

# Calculate Mean Bias Error (MBE)
mbe <- sum(observed - predicted) / n

# Calculate Pearson Correlation Coefficient (R)
pearson_corr <- cor(observed, predicted, method = "pearson")

# Calculate R-squared (RÂ²)
r_squared <- 1 - (sum((observed - predicted)^2) / sum((observed - mean(observed))^2))

# Create a summary table for the metrics
metrics_table <- data.frame(
  Metric = c("MAE (m)", 
             "RMSE (m)", 
             "Mean Bias Error (MBE) (m)", 
             "Pearson Correlation Coefficient (r) (-1 to +1)",
             "R-squared (0-1)"),
  Value = c(mae, rmse, mbe, pearson_corr, r_squared)
)

# Print the metrics table
print(metrics_table)

```

Height classes
```{r}
# Load required libraries
library(dplyr)
library(tidyr)

# Create height bins (3m bins, from 0 to 30m)
test1 <- test1 %>%
  mutate(height_class = cut(ALS, breaks = seq(0, 30, by = 3), include.lowest = TRUE))

# Function to calculate the metrics
calculate_metrics <- function(df) {
  n <- nrow(df)
  mae <- mean(abs(df$ALS - df$CNN), na.rm = TRUE)
  rmse <- sqrt(mean((df$ALS - df$CNN)^2, na.rm = TRUE))
  mbe <- mean(df$CNN - df$ALS, na.rm = TRUE)
  r2 <- summary(lm(CNN ~ ALS, data = df))$r.squared
  r <- cor(df$ALS, df$CNN, use = "complete.obs")
  
  return(c(MAE = mae, RMSE = rmse, MBE = mbe, R2 = r2, Pearson_R = r))
}

# Group by height classes and calculate the metrics for each class
metrics_by_class <- test1 %>%
  group_by(height_class) %>%
  summarise(MAE = mean(abs(ALS - CNN), na.rm = TRUE),
            RMSE = sqrt(mean((ALS - CNN)^2, na.rm = TRUE)),
            MBE = mean(CNN - ALS, na.rm = TRUE),
            R2 = summary(lm(CNN ~ ALS))$r.squared,
            Pearson_R = cor(ALS, CNN, use = "complete.obs"))

# View the resulting table
print(metrics_by_class)
```

```{r}
# Reshape the data to long format for easier plotting
library(ggplot2)
library(tidyr)

# Reshape the metrics_by_class to long format
metrics_long <- metrics_by_class %>%
  pivot_longer(cols = c(MAE, RMSE, MBE), 
               names_to = "Metric", 
               values_to = "Value")

# Plot the metrics using ggplot
ggplot(metrics_long, aes(x = height_class, y = Value, fill = Metric)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_viridis_d() +  # Use viridis color palette
  labs(title = "Error Metrics by Height Class",
       x = "Height Class (m)", 
       y = "Error (m)", 
       fill = "Metric") +
  theme_minimal()

```

```{r}
save.image("Metrics.RData")
```

