---
title: "Untitled"
author: "abbey yatsko"
date: "2024-10-11"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(tidyr)
library(dplyr)
```

load data
```{r}
tony_outputs_original <- read.csv("data/tony_output_original.csv")
tony_outputs_far <- read.csv("data/tony_output_far.csv")

tony_outputs <- rbind(tony_outputs_original, tony_outputs_far)
```

working with Tony's outputs: full list of fulls 
```{r}
tony_outputs$name <- sub(".*_", "", tony_outputs$name)
outputs <- tony_outputs
length(unique(outputs$name)) # 32 different folds 
```

weight by area, translate heights to shade volume, calculate residuals
```{r}
# weight by area 
outputs$weighted_test_area <- outputs$test_area / 900

# heights to shade volume, weighted by test area
outputs <- outputs %>%
  mutate(ground_truth_mean_sv = (ground_truth_mean*weighted_test_area),
         prediction_mean_sv = (prediction_mean*weighted_test_area))

outputs <- outputs %>%
  mutate(residuals = ground_truth_mean_sv - prediction_mean_sv)

outputs <- na.omit(outputs)
```

Calculate error metrics 
```{r}
# Group by height classes and calculate the metrics for the whole dataset
metrics_all <- outputs %>%
  group_by(name) %>% # remove height_class if you want to calculate for the whole dataset
  summarise(MAE = mean(abs(ground_truth_mean_sv - prediction_mean_sv), na.rm = TRUE),
            RMSE = sqrt(mean((ground_truth_mean_sv - prediction_mean_sv)^2, na.rm = TRUE)),
            MBE = mean(prediction_mean_sv - ground_truth_mean_sv, na.rm = TRUE),
            R2 = summary(lm(prediction_mean_sv ~ ground_truth_mean_sv))$r.squared,
            mean_observed = mean(ground_truth_mean_sv), 
            MAE_p = MAE / mean_observed, 
            RMSE_p = RMSE / mean_observed, 
            MBE_p = MBE / mean_observed, 
            MAE_p_inv = 1- MAE_p, 
            RMSE_p_inv = 1 - RMSE_p, 
            MBE_p_inv = 1 - MBE_p) # mean of observed shade volume for a given fold

metrics_all <- as.data.frame(metrics_all)
```

Visualization
```{r}
# convert to long format by height class
metrics_long_all <- metrics_all %>%
  pivot_longer(cols = c(MAE, MAE_p, RMSE, RMSE_p, MBE, MBE_p, R2, mean_observed), 
               names_to = "Metric", 
               values_to = "Value")

ggplot(metrics_long_all, aes(x = Metric, y = Value, color = Metric)) +
  geom_boxplot() +  # Change to boxplo
  labs(title = "Mean Error Metrics",
       x = "Metric", 
       y = "Error") +
  facet_wrap(~Metric, scales = "free", ncol = 3) +  # Facet by Metric
  theme_minimal()  # Minimal theme for a clean look

# density plot to compare ALS and CNN model
# group by name, calculate average of ground truth and prediction
outputs_fold_mean <- outputs %>%
  group_by(name) %>%
  summarise(prediction_fold_mean = mean(prediction_mean_sv, na.rm = TRUE),
            ground_truth_fold_mean = mean(ground_truth_mean_sv, na.rm = TRUE))

outputs_long <- outputs[, c("prediction_mean_sv", "ground_truth_mean_sv", "name")]

# merge outputs_long with outputs_fold_mean
outputs_long <- merge(outputs_long, outputs_fold_mean, by = "name", all.x = TRUE)

outputs_long <- pivot_longer(outputs_long, cols = c("prediction_mean_sv", "ground_truth_mean_sv"), names_to = "indexes", values_to = "values")

# for each fold
ggplot(outputs_long, aes(x = values,  fill = indexes, group = indexes)) +  
  theme_bw() +
  labs(x = "Shade Volume", y = "Frequency") +
  guides(fill = guide_legend(title = "Indexes"),
         color = guide_legend(title = "Indexes")) +
  facet_wrap(~name) + 
  scale_fill_manual(values = c("#7b6f89", "#FFDB58"), labels = c("Ground truth ALS", "CNN modeled")) +
  scale_color_manual(values = c("#7b6f89", "#FFDB58", "#7b6f89", "#FFDB58"), 
                     labels = c("Ground truth ALS", "CNN modeled", "Ground truth ALS", "CNN modeled")) +
  geom_density(aes(y = ..density.., fill = indexes, color = indexes), inherit.aes = TRUE, alpha=.6) +
  geom_vline(aes(xintercept = prediction_fold_mean, color = "CNN modeled"), linetype = "dashed", size = 1) +
  geom_vline(aes(xintercept = ground_truth_fold_mean, color = "Ground truth ALS"), linetype = "dotted", size = 1) +
  theme(axis.title = element_text(size = 14, face = "bold", color = "gray20"),
        axis.text.x.bottom = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        legend.direction = "horizontal",
        legend.position = "bottom",
        legend.title = element_text(size = 14, face = "bold"),
        legend.text = element_text(size = 14),
        title = element_text(size = 14),
        panel.spacing = unit(1, "lines"),
        strip.text = element_text(size = 12))

# all folds together
prediction_fold_mean <- mean(outputs_fold_mean$prediction_fold_mean, na.rm = TRUE)
ground_truth_fold_mean <- mean(outputs_fold_mean$ground_truth_fold_mean, na.rm = TRUE)

ggplot(outputs_long, aes(x = values,  fill = indexes)) +  
  theme_bw() +
  labs(x = "Shade Volume", y = "Frequency") +
  geom_density(aes(y = ..density.., fill = indexes), inherit.aes = TRUE, alpha=.6) +
  #geom_vline(aes(xintercept = 2.029173), color = "#FFDB58", linetype = "dashed", size = 1) +
 # geom_vline(aes(xintercept = 2.029006), color = "#7b6f89", linetype = "dotted", size = 1) +
  scale_fill_manual(values = c("#7b6f89", "#FFDB58"), 
                     labels = c("Ground truth ALS", "CNN modeled")) +
  theme(axis.title = element_text(size = 14, face = "bold", color = "gray20"),
        axis.text.x.bottom = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        legend.direction = "horizontal",
        legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 14),
        title = element_text(size = 14),
        panel.spacing = unit(1, "lines"),
        strip.text = element_text(size = 12))

```

Summary of metrics
```{r}
library(dplyr)
library(tibble)

# Convert all columns except the first one to numeric
metrics_all_numeric <- metrics_all %>%
  mutate_at(vars(-1), as.numeric)

# Calculate the mean for each numeric column (excluding the first)
means <- colMeans(metrics_all_numeric[, -1], na.rm = TRUE)

# Calculate the standard deviation for each numeric column (excluding the first)
sds <- apply(metrics_all_numeric[, -1], 2, sd, na.rm = TRUE)

# Create a tibble with means and standard deviations as rows
results_tibble <- tibble(
  Statistic = c("Mean", "Standard Deviation"),
  MAE = c(means["MAE"], sds["MAE"]),
  RMSE = c(means["RMSE"], sds["RMSE"]),
  MBE = c(means["MBE"], sds["MBE"]),
  R2 = c(means["R2"], sds["R2"]),
  MAE_p = c(means["MAE_p"], sds["MAE_p"]),
  RMSE_p = c(means["RMSE_p"], sds["RMSE_p"]),
  MBE_p = c(means["MBE_p"], sds["MBE_p"])
)

# Print the tibble
print(results_tibble)
write.csv(results_tibble, "metrics_summary.csv", row.names = FALSE)
```


Weighted error by fold
```{r}
# weighted error calculation 
alpha <- 1/3  # Weight for MAE
beta <- 1/3   # Weight for RMSE
gamma <- 1/3  # Weight for RÂ²

metrics_all <- metrics_all %>%
  group_by(name) %>%
  mutate(
    Raw_Weight = alpha * MAE_p_inv + beta * RMSE_p_inv + gamma * R2
  )

# plot to make sure it makes sense - there should be a strong correlation between higher R2 and weight
ggplot(metrics_all, aes(x = R2, y = Raw_Weight)) +
  geom_point() + 
  theme_classic()

# there should be a strong correlation between higher RMSE and weight
ggplot(metrics_all, aes(x = RMSE_p_inv, y = Raw_Weight)) +
  geom_point() + 
  theme_classic()

# there should be a strong correlation between higher MAE and weight
ggplot(metrics_all, aes(x = MAE_p_inv, y = Raw_Weight)) +
  geom_point() + 
  theme_classic()

# export as csv
# write.csv(metrics_all, "data/data_out/metrics_all.csv", row.names = FALSE)
```

EXTRA Error by height classes
```{r}
# Create height bins (3m bins, from 0 to 30m)
outputs <- outputs %>%
  mutate(height_class = cut(ground_truth_mean, breaks = seq(0, 30, by = 3), include.lowest = TRUE))

# Group by height classes and calculate the metrics for each class
metrics_by_class <- outputs %>%
  group_by(name, height_class) %>% # remove height_class if you want to calculate for the whole dataset
  summarise(MAE = mean(abs(ground_truth_mean_sv - prediction_mean_sv), na.rm = TRUE),
            RMSE = sqrt(mean((ground_truth_mean_sv - prediction_mean_sv)^2, na.rm = TRUE)),
            MBE = mean(prediction_mean_sv - ground_truth_mean_sv, na.rm = TRUE),
            R2 = summary(lm(prediction_mean_sv ~ ground_truth_mean_sv))$r.squared,
            Pearson_R = cor(ground_truth_mean_sv, prediction_mean_sv, use = "complete.obs"),
            MAPE = mean(abs((ground_truth_mean_sv - prediction_mean_sv) / ground_truth_mean_sv) * 100, na.rm = TRUE)) # Add MAPE

# convert to long format by height class
metrics_long <- metrics_by_class %>%
  pivot_longer(cols = c(MAE, RMSE, MBE, R2, Pearson_R, MAPE), 
               names_to = "Metric", 
               values_to = "Value")

# visualization: error by height class
ggplot(metrics_long, aes(x = height_class, y = Value, fill = height_class)) +
  geom_boxplot() +  # Change to boxplot
  scale_fill_viridis_d() +  # Use viridis color palette
  labs(title = "Error Metrics by Height Class",
       x = "Height Class (m)", 
       y = "Error (m)", 
       fill = "Height class") +
  facet_wrap(~Metric, scales = "free", ncol = 3) +  # Facet by Metric
  theme_minimal()  # Minimal theme for a clean look
```

```







